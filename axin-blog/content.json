{"meta":{"title":"axin-blog","subtitle":"学无止境，及时记录","description":"","author":"Axin","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-08-04T11:16:33.133Z","updated":"2020-08-04T11:16:33.133Z","comments":false,"path":"/404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-08-05T02:03:31.752Z","updated":"2020-08-05T02:03:31.752Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"前端小菜鸟"},{"title":"分类","date":"2020-08-04T11:16:33.134Z","updated":"2020-08-04T11:16:33.134Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-08-04T11:16:33.135Z","updated":"2020-08-04T11:16:33.135Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-08-04T11:16:33.135Z","updated":"2020-08-04T11:16:33.135Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-08-04T11:16:33.135Z","updated":"2020-08-04T11:16:33.135Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"hook异步更新问题","slug":"hook异步更新问题","date":"2020-08-03T11:27:50.000Z","updated":"2020-08-05T03:43:49.295Z","comments":true,"path":"React/React-Hook/hook异步更新问题/","link":"","permalink":"http://yoursite.com/React/React-Hook/hook%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/","excerpt":"","text":"在最近的工作中，初次尝试使用hook写一个完整的组件。果然第一次就遇到了问题。 需求这里我们先不要管代码写的逻辑问题。我们需要一个下拉组件，用户可以多选，可以清空。每次修改的时候都会去判断是否为空，如果为空的话给出警告（非常简单） 编码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import React, &#123; useState &#125; from 'react';import &#123; fromJS &#125; from 'immutable';import &#123; Select &#125; from 'antd';const &#123; Option &#125; = Select;function HooksAsync() &#123; const foodList = ['苹果', '梨', '米饭', '面条', '牛肉', '牛奶']; const initCheckedFoods = &#123; count: 0, value: [], error: '' &#125;; const [foods, setFoods] = useState(fromJS(initCheckedFoods)); const handleChange = (value) =&gt; &#123; setFoods(foods .set('value', fromJS(value)) .set('count', value.length) ); if (value.length === 0) &#123; setFoods(foods.set('error', '不能为空')) &#125; &#125;; return ( &lt;&gt; &lt;div&gt; 异常：&#123;foods.error&#125; &lt;/div&gt; &lt;Select allowClear mode=\"multiple\" style=&#123;&#123;width: 500&#125;&#125; placeholder=\"请选择食物\" value=&#123;foods.get('value').toJS()&#125; onChange=&#123;handleChange&#125; &gt; &#123; foodList.map((food) =&gt; ( &lt;Option key=&#123;food&#125; value=&#123;food&#125; &gt; &#123;food&#125; &lt;/Option&gt; )) &#125; &lt;/Select&gt; &lt;/&gt; );&#125;export default HooksAsync; bug出现当我们点击清除按钮以及删除至最后一个触发错误提示逻辑的时候，并没有把选择项清除掉。也没有出来我们期望的错误提示。 bug定位经过摸爬滚打的排查。发现是因为hook和setState一样，更新操作是异步的。以上bug可以还原为这样子。 123456789101112131415const handleChange = (value) =&gt; &#123; const currentFoods = foods; // 修改currentFoods的value和count属性，返回新值赋值给foods setFoods(currentFoods .set('value', fromJS(value)) .set('count', value.length) ); // 这里拿到的还是currentFoods，而不是新的foods。immutablejs修改之后，会返回新的对象，原来的还是原来的。 // 所以这里的currentFoods并没有value和count的改变。 // 修改currentFoods的error属性，返回新值赋值给foods if (value.length === 0) &#123; setFoods(currentFoods.set('error', '不能为空')) &#125;&#125;; 可以看到，其实我们只是把修改了error的新值赋值给了foods而已。第一个setFoods完全被忽略了。 怎么解决 使用函数做参数，和setState一样 123if (value.length === 0) &#123; setFoods((foods) =&gt; foods.set('error', '不能为空'))&#125; useRef 1234567891011121314const [foods, setFoods] = useState(fromJS(initCheckedFoods));const foodRef = useRef(foods);const handleChange = (value) =&gt; &#123; setFoods(foodRef.current .set('value', fromJS(value)) .set('count', value.length) ); if (value.length === 0) &#123; setFoods(foodRef.current.set('error', '不能为空')) &#125;&#125;; 总结和 setState 一样，其实hook更新数据也是异步的。这个其实在react常用的人手上是不会出这个问题的。奈何我一个新手还是去淌了一遍。。","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"},{"name":"React-Hook","slug":"React/React-Hook","permalink":"http://yoursite.com/categories/React/React-Hook/"}],"tags":[{"name":"Hook, async","slug":"Hook-async","permalink":"http://yoursite.com/tags/Hook-async/"}]},{"title":"Route组件渲染的几种方式","slug":"Route组件渲染的几种方式","date":"2020-07-28T08:51:40.000Z","updated":"2020-08-04T13:20:56.889Z","comments":true,"path":"React/React-Router/Route组件渲染的几种方式/","link":"","permalink":"http://yoursite.com/React/React-Router/Route%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"&lt;Route&gt; 组件是 React-Router 提供的用于当路由匹配上之后渲染用户组件的一个组件 渲染组件的方式component比较容易理解，直接传递一个组件。官网示例: 123456789101112131415import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Route &#125; from \"react-router-dom\";// All route props (match, location and history) are available to Userfunction User(props) &#123; return &lt;h1&gt;Hello &#123;props.match.params.username&#125;!&lt;/h1&gt;;&#125;ReactDOM.render( &lt;Router&gt; &lt;Route path=\"/user/:username\" component=&#123;User&#125; /&gt; &lt;/Router&gt;, node); 不要尝试用内联方法的方式赋值给 component 属性，如以下示例所示： 1&lt;Route path=\"/user/:username\" component=&#123;() =&gt; &lt;User /&gt;)&#125; /&gt; 这样会导致每次重新渲染的时候都是一个新的 User 组件 render function在某些情况下，我们可能希望能经过一些计算来在一个路由上显示不同的组件。如下所示： 12345678910111213141516171819import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Route &#125; from \"react-router-dom\";const day = 1;// convenient inline renderingReactDOM.render( &lt;Router&gt; &lt;Route path=\"/home\" render=&#123;(props) =&gt; &#123; if(day === 1) &#123; return &lt;Monday /&gt; &#125; else &#123; return &lt;NotMonday /&gt; &#125; &#125;&#125; /&gt; &lt;/Router&gt;, node); 与将内联方法传递给 component 属性不同，使用此方式，不会造成组件的重复渲染 props 参数为 { match, location, history } component 属性的优先级要高于 render 。避免将两个属性同时使用在一个路由组件上。 children functionchildren function 与 render function 的使用方式一样。不同的地方在于，当路由匹配失败后，match 参数会是 null 。我们可以根据这个特性来做一些事情。 官网代码示例，这里在匹配上的时候，增加了一个class： 123456789101112131415161718192021222324252627282930import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Link, Route&#125; from \"react-router-dom\";function ListItemLink(&#123; to, ...rest &#125;) &#123; return ( &lt;Route path=&#123;to&#125; children=&#123;(&#123; match &#125;) =&gt; ( &lt;li className=&#123;match ? \"active\" : \"\"&#125;&gt; &lt;Link to=&#123;to&#125; &#123;...rest&#125; /&gt; &lt;/li&gt; )&#125; /&gt; );&#125;ReactDOM.render( &lt;Router&gt; &lt;ul&gt; &lt;ListItemLink to=\"/somewhere\" /&gt; &lt;ListItemLink to=\"/somewhere-else\" /&gt; &lt;/ul&gt; &lt;/Router&gt;, node); children 属性的优先级要高于 render 和 component 。避免将多个属性同时使用在一个路由组件上。","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"},{"name":"React-Router","slug":"React/React-Router","permalink":"http://yoursite.com/categories/React/React-Router/"}],"tags":[{"name":"Route-Render","slug":"Route-Render","permalink":"http://yoursite.com/tags/Route-Render/"}]}],"categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"},{"name":"React-Hook","slug":"React/React-Hook","permalink":"http://yoursite.com/categories/React/React-Hook/"},{"name":"React-Router","slug":"React/React-Router","permalink":"http://yoursite.com/categories/React/React-Router/"}],"tags":[{"name":"Hook, async","slug":"Hook-async","permalink":"http://yoursite.com/tags/Hook-async/"},{"name":"Route-Render","slug":"Route-Render","permalink":"http://yoursite.com/tags/Route-Render/"}]}