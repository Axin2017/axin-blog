{"meta":{"title":"axin-blog","subtitle":"学无止境，及时记录","description":"","author":"Axin","url":"http://www.axin-blog.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-08-04T11:16:33.133Z","updated":"2020-08-04T11:16:33.133Z","comments":false,"path":"/404.html","permalink":"http://www.axin-blog.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-08-05T02:03:31.752Z","updated":"2020-08-05T02:03:31.752Z","comments":false,"path":"about/index.html","permalink":"http://www.axin-blog.com/about/index.html","excerpt":"","text":"前端小菜鸟"},{"title":"分类","date":"2020-08-04T11:16:33.134Z","updated":"2020-08-04T11:16:33.134Z","comments":false,"path":"categories/index.html","permalink":"http://www.axin-blog.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-08-04T11:16:33.135Z","updated":"2020-08-04T11:16:33.135Z","comments":false,"path":"tags/index.html","permalink":"http://www.axin-blog.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-08-04T11:16:33.135Z","updated":"2020-08-04T11:16:33.135Z","comments":true,"path":"links/index.html","permalink":"http://www.axin-blog.com/links/index.html","excerpt":"","text":""},{"title":"项目","date":"2020-08-10T04:01:05.130Z","updated":"2020-08-10T04:01:05.130Z","comments":false,"path":"repository/index.html","permalink":"http://www.axin-blog.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"FLIP动画简介","slug":"FLIP动画简介","date":"2020-08-24T12:03:56.000Z","updated":"2020-08-27T06:30:55.604Z","comments":true,"path":"animation/FLIP动画简介/","link":"","permalink":"http://www.axin-blog.com/animation/FLIP%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B/","excerpt":"","text":"今天的目标 FLIP简介FLIP 是将一些开销高昂的动画，如针对 width，height，left 或 top 的动画，映射为 transform 动画。通过记录元素的两个快照，一个是元素的初始位置（First - F），另一个是元素的最终位置（Last - L），然后对元素使用一个 transform 变换来反转（Invert - I），让元素看起来还在初始位置，最后移除元素上的 transform 使元素由初始位置运动（Play - P）到最终位置。 所以 FLIP 来源于 First，Last，Invert，Play F: first, 元素的初始状态 L: last, 元素的结束状态 I: invert, 倒置，把始末的状态导致过来 P: play, 播放动画 需理解的前提知识浏览器的事件执行顺序 三个小例子一次宏任务执行完毕之后,浏览器才会渲染 1234document.body.style = 'background:black';document.body.style = 'background:red';document.body.style = 'background:blue';document.body.style = 'background:grey'; 宏任务–&gt;渲染–&gt;宏任务 1234document.body.style = 'background:blue';setTimeout(function()&#123; document.body.style = 'background:black'&#125;,0) 宏任务–&gt;微任务–&gt;渲染 1234document.body.style = 'background:blue';Promise.resolve().then(() =&gt; &#123; document.body.style = 'background:black'&#125;) getBoundingClientRectElement.getBoundingClientRect() 方法返回元素的大小及其相对于视口的位置。 这个api的可以在浏览器渲染前就计算元素所处的最新位置信息 为什么使用tranform, opacity 等属性做动画会比直接改变Left,top等属性做动画更好为了生成流畅的动画，你需要让浏览器尽可能少地工作，最好的办法就是充分利用 GPU，并避免动画过程中触发页面重排或重绘。目前 Chrome，Firefox，Safari，Opera 和 IE11 都对 transform（translate，rotate 和 scale） 和 opacity 进行硬件加速。所以我们应该尽量使用 transform 和 opacity 属性来实现我们的动画. 伪代码12345678910111213141516171819202122232425262728// 获取初始位置var first = el.getBoundingClientRect();// 让元素在最终位置上.可以通过直接设置class,改变兄弟元素等等方式都行el.classList.add('class-end');// 获取最终位置var last = el.getBoundingClientRect();// 计算反转var invert = first.top - last.top;// 反转el.style.transform = 'translateY(' + invert + 'px)';// 播放setTimeout(function() &#123; // 添加动画相关的设置 el.classList.add('animate-on-transforms'); // 开始动画 el.style.transform = ''; &#125;, 0);// 结束时清理el.addEventListener('transitionend', () =&gt; &#123; el.classList.remove('animate-on-transforms'); // ...&#125;); 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;flip-animation-demo&lt;/title&gt; &lt;style&gt; .container &#123; display: flex; flex-wrap: wrap; &#125; img &#123; display: inline-block; width: 110px; height: 110px; margin: 5px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"container\"&gt;&lt;/div&gt; &lt;script&gt; function insert(count) &#123; const allImgs = container.querySelectorAll('img'); allImgs.forEach(img =&gt; &#123; // 先记录下原始位置 FIRST const &#123; left, top &#125; = img.getBoundingClientRect(); img._top = top; img._left = left; &#125;) count = count || 1; for (let i = 0; i &lt; count; i++) &#123; const img = document.createElement('img'); const random = Math.floor(Math.random() * 9) + 1; img.src = `./images/$&#123;random&#125;.jpeg`; container.insertBefore(img, container.firstChild); // 绑定事件，动画结束之后清空transition和transform img.addEventListener('transitionend', () =&gt; &#123; img.style.transition = ''; img.style.transform = ''; &#125;); &#125; allImgs.forEach(img =&gt; &#123; // 得到现在的位置 Last const &#123; left, top &#125; = img.getBoundingClientRect(); // 倒置 Invert const top_distance = img._top - top; const left_distance = img._left - left; img.style.transform = `translate($&#123;left_distance&#125;px, $&#123;top_distance&#125;px)`; // Play setTimeout(() =&gt; &#123; img.style.transition = 'all .5s'; img.style.transform = 'none'; &#125;, 0); &#125;); &#125; // setInterval(insert, 2000) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 图片资源请自行寻找.本例子是选了9张图片分别命名为1-9.jpeg,放在与html同级目录下的images文件夹中 FAQFLIP 适合用在什么地方 两个状态的过度 元素增加,移除 展开,收缩 打乱顺序/重新排列 为什么要用倒置,而不是通过加transform直接从开始到结束 很难知道结束的位置,步骤繁琐,难以理解 从开始到结束的时候,浏览器需要计算结束的位置.导致过来的时候,浏览器其实已经知道了结束的位置.更快. 一直用从开始到结束的话,需要一直去维护transform的值,且容易弄脏css 对性能的影响从交互结束到感知到响应大概需要 100ms 的生理反应时间,如果网站能在这 100ms 内做出响应，那么对用户来说就相当于网站立即进行了响应，然后只需要保证动画在 60FPS 运行就能给用户带来最佳的体验.我们可以充分利用用户 100ms 生理反应时间来进行相关的计算：getBoundingClientRect 或 getComputedStyle，并通过 FLIP 技术使动画尽快开始，最后通过 transform 和 opacity 的动画来保证动画的平滑运行. FLIP 技术带来的改变对于 PC 端可能并不是那么明显，但对于 CPU 并不算非常强大的移动端却是相当显著.","categories":[{"name":"animation","slug":"animation","permalink":"http://www.axin-blog.com/categories/animation/"}],"tags":[{"name":"FLIP","slug":"FLIP","permalink":"http://www.axin-blog.com/tags/FLIP/"}]},{"title":"使用simple-git编写一个git代码量统计工具","slug":"使用simple-git编写一个git代码量统计工具","date":"2020-08-17T13:13:19.000Z","updated":"2020-08-18T02:47:32.910Z","comments":true,"path":"node-cli/git/使用simple-git编写一个git代码量统计工具/","link":"","permalink":"http://www.axin-blog.com/node-cli/git/%E4%BD%BF%E7%94%A8simple-git%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAgit%E4%BB%A3%E7%A0%81%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%B7%A5%E5%85%B7/","excerpt":"","text":"背景公司每周都要统计代码量。最近新入职，代码量不是很多，开始的时候，一直是直接在gitlab上看我的提交，一次一次地累加，好蠢有没有… 偶然之间，了解了刚离职的大佬同事以前是用shell脚本来自动统计的，大牛有木有！顺带帮传宣下：git代码统计脚本 最近，公司架构组大佬写了一个git自动部署的工具，加之我又没有被分配需求，就研究了一下。收获颇多，突发奇想，这个统计代码的工具，我干脆自己来写一个！ 使用到的库 simple-git simple-git 一个git的轻量级nodejs接口 chalk chalk 一个可以在控制台输出花里胡哨的颜色文字的炫酷工具 inquirer inquirer 一个可以在控制台跟用户交互并且收集用户输入的参数的库 核心apigit相关： 12345678910111213141516// 新建git对象const simpleGit = require('simple-git');const git = simpleGit('D:/xxx/xxx');// 以下方法均返回promise// 获取本地分支git.branchLocal()// 切换到某个分支git.checkout(branch)// 获取提交日志git.log(&#123; '--stat': true, '--since': '2020-01-01', '--until': '2020-01-02', '--author': 'your name' &#125;); 交互相关： 1234567891011121314151617181920212223242526// 单个参数输入const &#123; workSpace &#125; = await inquirer.prompt([&#123; name: 'workSpace', message: '输入你的工作目录', validate: answer =&gt; &#123; try &#123; if (!answer || !fs.statSync(answer.trim()).isDirectory) &#123; return '输入的路径不是合法的目录'; &#125; return true; &#125; catch &#123; return '输入的路径不是合法的目录'; &#125; &#125; &#125;]);// 列表多选const &#123; projectList &#125; = await inquirer.prompt(&#123; name: 'projectList', message: '请选择要统计的项目，空格选择，回车结束选择', type: 'checkbox', choices: ['projectA', 'projectB', 'projectC'], validate: checkedList =&gt; &#123; return checkedList.length &gt; 0 || '请选择至少一个项目'; &#125; &#125;); 控制台输出相关： 1console.log(chalk.green('这句代码会在控制台输出绿色的字')) 开始编写其实这些api都会使用了之后，我们这个工具的编写就变得非常简单了起来。这里我把主要思路写一下，具体代码请见文末贴出来的git地址 输入工作目录 输入要统计的开始时间 输入要统计的结束时间 输入作者关键字 根据输入的工作目录，循环遍历目录中的子文件夹，如果子文件夹中有.git目录，则认为该目录是一个git项目，存入列表。最终得到一个项目列表，供用户选择要统计的项目。 根据用户选择后得到的项目列表，一一循环获得每个项目的本地分支，得到每个项目的分支列表。一一循环每个项目及每个分支，供用户选择要统计的分支。 根据得到的所有参数，循环项目，分支，一一统计得到每个分支，每个项目，及总共的代码变动量。 按照特定的格式输出结果。 体验一下 在windows的cmd窗口中，偶尔会出现上面动图中标题输出多次的bug，目前不明真相。在vscode的终端中不会有这个问题。有空的时候继续研究一下。。 代码仓库地址git-code-count 欢迎使用，提出issues以及在博客上留言提出你想要的功能，我将会持续维护。 显示多行后续在文章的上部分，我贴了一张体验动图，可以发现，当我按箭头上下切换的时候，重复显示了很多行 经过我后续的测试，发现，当标题为中文，且一行显示不完的时候，就会有这样的问题。所以大家使用的时候，最好把cmd窗口放大。要不然我就把我的问题改成英文的。。。暂时先放大吧哈哈。 对此我已经提了issue在原作者的github上。 it will render repeat lines of title on Windows when the property of message is Chinese and too long to display in a single line","categories":[{"name":"node-cli","slug":"node-cli","permalink":"http://www.axin-blog.com/categories/node-cli/"},{"name":"git","slug":"node-cli/git","permalink":"http://www.axin-blog.com/categories/node-cli/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.axin-blog.com/tags/git/"}]},{"title":"hook异步更新问题","slug":"hook异步更新问题","date":"2020-08-03T11:27:50.000Z","updated":"2020-08-17T13:54:53.474Z","comments":true,"path":"React/React-Hook/hook异步更新问题/","link":"","permalink":"http://www.axin-blog.com/React/React-Hook/hook%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/","excerpt":"","text":"在最近的工作中，初次尝试使用hook写一个完整的组件。果然第一次就遇到了问题。 需求这里我们先不要管代码写的逻辑问题。我们需要一个下拉组件，用户可以多选，可以清空。每次修改的时候都会去判断是否为空，如果为空的话给出警告（非常简单） 编码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import React, &#123; useState &#125; from 'react';import &#123; fromJS &#125; from 'immutable';import &#123; Select &#125; from 'antd';const &#123; Option &#125; = Select;function HooksAsync() &#123; const foodList = ['苹果', '梨', '米饭', '面条', '牛肉', '牛奶']; const initCheckedFoods = &#123; count: 0, value: [], error: '' &#125;; const [foods, setFoods] = useState(fromJS(initCheckedFoods)); const handleChange = (value) =&gt; &#123; setFoods(foods .set('value', fromJS(value)) .set('count', value.length) ); if (value.length === 0) &#123; setFoods(foods.set('error', '不能为空')) &#125; &#125;; return ( &lt;&gt; &lt;div&gt; 异常：&#123;foods.error&#125; &lt;/div&gt; &lt;Select allowClear mode=\"multiple\" style=&#123;&#123;width: 500&#125;&#125; placeholder=\"请选择食物\" value=&#123;foods.get('value').toJS()&#125; onChange=&#123;handleChange&#125; &gt; &#123; foodList.map((food) =&gt; ( &lt;Option key=&#123;food&#125; value=&#123;food&#125; &gt; &#123;food&#125; &lt;/Option&gt; )) &#125; &lt;/Select&gt; &lt;/&gt; );&#125;export default HooksAsync; bug出现当我们点击清除按钮以及删除至最后一个触发错误提示逻辑的时候，并没有把选择项清除掉。也没有出来我们期望的错误提示。 bug定位经过摸爬滚打的排查。发现是因为hook和setState一样，更新操作是异步的。以上bug可以还原为这样子。 123456789101112131415const handleChange = (value) =&gt; &#123; const currentFoods = foods; // 修改currentFoods的value和count属性，返回新值赋值给foods setFoods(currentFoods .set('value', fromJS(value)) .set('count', value.length) ); // 这里拿到的还是currentFoods，而不是新的foods。immutablejs修改之后，会返回新的对象，原来的还是原来的。 // 所以这里的currentFoods并没有value和count的改变。 // 修改currentFoods的error属性，返回新值赋值给foods if (value.length === 0) &#123; setFoods(currentFoods.set('error', '不能为空')) &#125;&#125;; 可以看到，其实我们只是把修改了error的新值赋值给了foods而已。第一个setFoods完全被忽略了。 怎么解决 使用函数做参数，和setState一样 123if (value.length === 0) &#123; setFoods((foods) =&gt; foods.set('error', '不能为空'))&#125; useRef 1234567891011121314const [foods, setFoods] = useState(fromJS(initCheckedFoods));const foodRef = useRef(foods);const handleChange = (value) =&gt; &#123; setFoods(foodRef.current .set('value', fromJS(value)) .set('count', value.length) ); if (value.length === 0) &#123; setFoods(foodRef.current.set('error', '不能为空')) &#125;&#125;; 总结和 setState 一样，其实hook更新数据也是异步的。这个其实在react常用的人手上是不会出这个问题的。奈何我一个新手还是去淌了一遍。。","categories":[{"name":"React","slug":"React","permalink":"http://www.axin-blog.com/categories/React/"},{"name":"React-Hook","slug":"React/React-Hook","permalink":"http://www.axin-blog.com/categories/React/React-Hook/"}],"tags":[{"name":"Hook, async","slug":"Hook-async","permalink":"http://www.axin-blog.com/tags/Hook-async/"}]},{"title":"Route组件渲染的几种方式","slug":"Route组件渲染的几种方式","date":"2020-07-28T08:51:40.000Z","updated":"2020-08-04T13:20:56.889Z","comments":true,"path":"React/React-Router/Route组件渲染的几种方式/","link":"","permalink":"http://www.axin-blog.com/React/React-Router/Route%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"&lt;Route&gt; 组件是 React-Router 提供的用于当路由匹配上之后渲染用户组件的一个组件 渲染组件的方式component比较容易理解，直接传递一个组件。官网示例: 123456789101112131415import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Route &#125; from \"react-router-dom\";// All route props (match, location and history) are available to Userfunction User(props) &#123; return &lt;h1&gt;Hello &#123;props.match.params.username&#125;!&lt;/h1&gt;;&#125;ReactDOM.render( &lt;Router&gt; &lt;Route path=\"/user/:username\" component=&#123;User&#125; /&gt; &lt;/Router&gt;, node); 不要尝试用内联方法的方式赋值给 component 属性，如以下示例所示： 1&lt;Route path=\"/user/:username\" component=&#123;() =&gt; &lt;User /&gt;)&#125; /&gt; 这样会导致每次重新渲染的时候都是一个新的 User 组件 render function在某些情况下，我们可能希望能经过一些计算来在一个路由上显示不同的组件。如下所示： 12345678910111213141516171819import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Route &#125; from \"react-router-dom\";const day = 1;// convenient inline renderingReactDOM.render( &lt;Router&gt; &lt;Route path=\"/home\" render=&#123;(props) =&gt; &#123; if(day === 1) &#123; return &lt;Monday /&gt; &#125; else &#123; return &lt;NotMonday /&gt; &#125; &#125;&#125; /&gt; &lt;/Router&gt;, node); 与将内联方法传递给 component 属性不同，使用此方式，不会造成组件的重复渲染 props 参数为 { match, location, history } component 属性的优先级要高于 render 。避免将两个属性同时使用在一个路由组件上。 children functionchildren function 与 render function 的使用方式一样。不同的地方在于，当路由匹配失败后，match 参数会是 null 。我们可以根据这个特性来做一些事情。 官网代码示例，这里在匹配上的时候，增加了一个class： 123456789101112131415161718192021222324252627282930import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Link, Route&#125; from \"react-router-dom\";function ListItemLink(&#123; to, ...rest &#125;) &#123; return ( &lt;Route path=&#123;to&#125; children=&#123;(&#123; match &#125;) =&gt; ( &lt;li className=&#123;match ? \"active\" : \"\"&#125;&gt; &lt;Link to=&#123;to&#125; &#123;...rest&#125; /&gt; &lt;/li&gt; )&#125; /&gt; );&#125;ReactDOM.render( &lt;Router&gt; &lt;ul&gt; &lt;ListItemLink to=\"/somewhere\" /&gt; &lt;ListItemLink to=\"/somewhere-else\" /&gt; &lt;/ul&gt; &lt;/Router&gt;, node); children 属性的优先级要高于 render 和 component 。避免将多个属性同时使用在一个路由组件上。","categories":[{"name":"React","slug":"React","permalink":"http://www.axin-blog.com/categories/React/"},{"name":"React-Router","slug":"React/React-Router","permalink":"http://www.axin-blog.com/categories/React/React-Router/"}],"tags":[{"name":"Route-Render","slug":"Route-Render","permalink":"http://www.axin-blog.com/tags/Route-Render/"}]}],"categories":[{"name":"animation","slug":"animation","permalink":"http://www.axin-blog.com/categories/animation/"},{"name":"node-cli","slug":"node-cli","permalink":"http://www.axin-blog.com/categories/node-cli/"},{"name":"git","slug":"node-cli/git","permalink":"http://www.axin-blog.com/categories/node-cli/git/"},{"name":"React","slug":"React","permalink":"http://www.axin-blog.com/categories/React/"},{"name":"React-Hook","slug":"React/React-Hook","permalink":"http://www.axin-blog.com/categories/React/React-Hook/"},{"name":"React-Router","slug":"React/React-Router","permalink":"http://www.axin-blog.com/categories/React/React-Router/"}],"tags":[{"name":"FLIP","slug":"FLIP","permalink":"http://www.axin-blog.com/tags/FLIP/"},{"name":"git","slug":"git","permalink":"http://www.axin-blog.com/tags/git/"},{"name":"Hook, async","slug":"Hook-async","permalink":"http://www.axin-blog.com/tags/Hook-async/"},{"name":"Route-Render","slug":"Route-Render","permalink":"http://www.axin-blog.com/tags/Route-Render/"}]}