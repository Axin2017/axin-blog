{"meta":{"title":"axin-blog","subtitle":"学无止境，及时记录","description":"","author":"Axin","url":"http://www.axin-blog.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-08-04T11:16:33.133Z","updated":"2020-08-04T11:16:33.133Z","comments":false,"path":"/404.html","permalink":"http://www.axin-blog.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-08-05T02:03:31.752Z","updated":"2020-08-05T02:03:31.752Z","comments":false,"path":"about/index.html","permalink":"http://www.axin-blog.com/about/index.html","excerpt":"","text":"前端小菜鸟"},{"title":"分类","date":"2020-08-04T11:16:33.134Z","updated":"2020-08-04T11:16:33.134Z","comments":false,"path":"categories/index.html","permalink":"http://www.axin-blog.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-08-04T11:16:33.135Z","updated":"2020-08-04T11:16:33.135Z","comments":false,"path":"tags/index.html","permalink":"http://www.axin-blog.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-08-04T11:16:33.135Z","updated":"2020-08-04T11:16:33.135Z","comments":true,"path":"links/index.html","permalink":"http://www.axin-blog.com/links/index.html","excerpt":"","text":""},{"title":"项目","date":"2020-08-10T04:01:05.130Z","updated":"2020-08-10T04:01:05.130Z","comments":false,"path":"repository/index.html","permalink":"http://www.axin-blog.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"使用simple-git编写一个git代码量统计工具","slug":"使用simple-git编写一个git代码量统计工具","date":"2020-08-17T13:13:19.000Z","updated":"2020-08-18T02:39:01.170Z","comments":true,"path":"node-cli/git/使用simple-git编写一个git代码量统计工具/","link":"","permalink":"http://www.axin-blog.com/node-cli/git/%E4%BD%BF%E7%94%A8simple-git%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAgit%E4%BB%A3%E7%A0%81%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%B7%A5%E5%85%B7/","excerpt":"","text":"背景公司每周都要统计代码量。最近新入职，代码量不是很多，开始的时候，一直是直接在gitlab上看我的提交，一次一次地累加，好蠢有没有… 偶然之间，了解了刚离职的大佬同事以前是用shell脚本来自动统计的，大牛有木有！顺带帮传宣下：git代码统计脚本 最近，公司架构组大佬写了一个git自动部署的工具，加之我又没有被分配需求，就研究了一下。收获颇多，突发奇想，这个统计代码的工具，我干脆自己来写一个！ 使用到的库 simple-git simple-git 一个git的轻量级nodejs接口 chalk chalk 一个可以在控制台输出花里胡哨的颜色文字的炫酷工具 inquirer inquirer 一个可以在控制台跟用户交互并且收集用户输入的参数的库 核心apigit相关： 12345678910111213141516// 新建git对象const simpleGit = require('simple-git');const git = simpleGit('D:/xxx/xxx');// 以下方法均返回promise// 获取本地分支git.branchLocal()// 切换到某个分支git.checkout(branch)// 获取提交日志git.log(&#123; '--stat': true, '--since': '2020-01-01', '--until': '2020-01-02', '--author': 'your name' &#125;); 交互相关： 1234567891011121314151617181920212223242526// 单个参数输入const &#123; workSpace &#125; = await inquirer.prompt([&#123; name: 'workSpace', message: '输入你的工作目录', validate: answer =&gt; &#123; try &#123; if (!answer || !fs.statSync(answer.trim()).isDirectory) &#123; return '输入的路径不是合法的目录'; &#125; return true; &#125; catch &#123; return '输入的路径不是合法的目录'; &#125; &#125; &#125;]);// 列表多选const &#123; projectList &#125; = await inquirer.prompt(&#123; name: 'projectList', message: '请选择要统计的项目，空格选择，回车结束选择', type: 'checkbox', choices: ['projectA', 'projectB', 'projectC'], validate: checkedList =&gt; &#123; return checkedList.length &gt; 0 || '请选择至少一个项目'; &#125; &#125;); 控制台输出相关： 1console.log(chalk.green('这句代码会在控制台输出绿色的字')) 开始编写其实这些api都会使用了之后，我们这个工具的编写就变得非常简单了起来。这里我把主要思路写一下，具体代码请见文末贴出来的git地址 输入工作目录 输入要统计的开始时间 输入要统计的结束时间 输入作者关键字 根据输入的工作目录，循环遍历目录中的子文件夹，如果子文件夹中有.git目录，则认为该目录是一个git项目，存入列表。最终得到一个项目列表，供用户选择要统计的项目。 根据用户选择后得到的项目列表，一一循环获得每个项目的本地分支，得到每个项目的分支列表。一一循环每个项目及每个分支，供用户选择要统计的分支。 根据得到的所有参数，循环项目，分支，一一统计得到每个分支，每个项目，及总共的代码变动量。 按照特定的格式输出结果。 体验一下 在windows的cmd窗口中，偶尔会出现上面动图中标题输出多次的bug，目前不明真相。在vscode的终端中不会有这个问题。有空的时候继续研究一下。。 代码仓库地址git-code-count 欢迎使用，提出issues以及在博客上留言提出你想要的功能，我将会持续维护。 显示多行后续在文章的上部分，我贴了一张体验动图，可以发现，当我按箭头上下切换的时候，重复显示了很多行 经过我后续的测试，发现，当标题为中文，且一行显示不完的时候，就会有这样的问题。 对此我已经提了issue在原作者的github上。 it will render repeat lines of title on Windows when the prorerty of message is Chinese and too long to display in a single line","categories":[{"name":"node-cli","slug":"node-cli","permalink":"http://www.axin-blog.com/categories/node-cli/"},{"name":"git","slug":"node-cli/git","permalink":"http://www.axin-blog.com/categories/node-cli/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.axin-blog.com/tags/git/"}]},{"title":"hook异步更新问题","slug":"hook异步更新问题","date":"2020-08-03T11:27:50.000Z","updated":"2020-08-17T13:54:53.474Z","comments":true,"path":"React/React-Hook/hook异步更新问题/","link":"","permalink":"http://www.axin-blog.com/React/React-Hook/hook%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/","excerpt":"","text":"在最近的工作中，初次尝试使用hook写一个完整的组件。果然第一次就遇到了问题。 需求这里我们先不要管代码写的逻辑问题。我们需要一个下拉组件，用户可以多选，可以清空。每次修改的时候都会去判断是否为空，如果为空的话给出警告（非常简单） 编码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import React, &#123; useState &#125; from 'react';import &#123; fromJS &#125; from 'immutable';import &#123; Select &#125; from 'antd';const &#123; Option &#125; = Select;function HooksAsync() &#123; const foodList = ['苹果', '梨', '米饭', '面条', '牛肉', '牛奶']; const initCheckedFoods = &#123; count: 0, value: [], error: '' &#125;; const [foods, setFoods] = useState(fromJS(initCheckedFoods)); const handleChange = (value) =&gt; &#123; setFoods(foods .set('value', fromJS(value)) .set('count', value.length) ); if (value.length === 0) &#123; setFoods(foods.set('error', '不能为空')) &#125; &#125;; return ( &lt;&gt; &lt;div&gt; 异常：&#123;foods.error&#125; &lt;/div&gt; &lt;Select allowClear mode=\"multiple\" style=&#123;&#123;width: 500&#125;&#125; placeholder=\"请选择食物\" value=&#123;foods.get('value').toJS()&#125; onChange=&#123;handleChange&#125; &gt; &#123; foodList.map((food) =&gt; ( &lt;Option key=&#123;food&#125; value=&#123;food&#125; &gt; &#123;food&#125; &lt;/Option&gt; )) &#125; &lt;/Select&gt; &lt;/&gt; );&#125;export default HooksAsync; bug出现当我们点击清除按钮以及删除至最后一个触发错误提示逻辑的时候，并没有把选择项清除掉。也没有出来我们期望的错误提示。 bug定位经过摸爬滚打的排查。发现是因为hook和setState一样，更新操作是异步的。以上bug可以还原为这样子。 123456789101112131415const handleChange = (value) =&gt; &#123; const currentFoods = foods; // 修改currentFoods的value和count属性，返回新值赋值给foods setFoods(currentFoods .set('value', fromJS(value)) .set('count', value.length) ); // 这里拿到的还是currentFoods，而不是新的foods。immutablejs修改之后，会返回新的对象，原来的还是原来的。 // 所以这里的currentFoods并没有value和count的改变。 // 修改currentFoods的error属性，返回新值赋值给foods if (value.length === 0) &#123; setFoods(currentFoods.set('error', '不能为空')) &#125;&#125;; 可以看到，其实我们只是把修改了error的新值赋值给了foods而已。第一个setFoods完全被忽略了。 怎么解决 使用函数做参数，和setState一样 123if (value.length === 0) &#123; setFoods((foods) =&gt; foods.set('error', '不能为空'))&#125; useRef 1234567891011121314const [foods, setFoods] = useState(fromJS(initCheckedFoods));const foodRef = useRef(foods);const handleChange = (value) =&gt; &#123; setFoods(foodRef.current .set('value', fromJS(value)) .set('count', value.length) ); if (value.length === 0) &#123; setFoods(foodRef.current.set('error', '不能为空')) &#125;&#125;; 总结和 setState 一样，其实hook更新数据也是异步的。这个其实在react常用的人手上是不会出这个问题的。奈何我一个新手还是去淌了一遍。。","categories":[{"name":"React","slug":"React","permalink":"http://www.axin-blog.com/categories/React/"},{"name":"React-Hook","slug":"React/React-Hook","permalink":"http://www.axin-blog.com/categories/React/React-Hook/"}],"tags":[{"name":"Hook, async","slug":"Hook-async","permalink":"http://www.axin-blog.com/tags/Hook-async/"}]},{"title":"Route组件渲染的几种方式","slug":"Route组件渲染的几种方式","date":"2020-07-28T08:51:40.000Z","updated":"2020-08-04T13:20:56.889Z","comments":true,"path":"React/React-Router/Route组件渲染的几种方式/","link":"","permalink":"http://www.axin-blog.com/React/React-Router/Route%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"&lt;Route&gt; 组件是 React-Router 提供的用于当路由匹配上之后渲染用户组件的一个组件 渲染组件的方式component比较容易理解，直接传递一个组件。官网示例: 123456789101112131415import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Route &#125; from \"react-router-dom\";// All route props (match, location and history) are available to Userfunction User(props) &#123; return &lt;h1&gt;Hello &#123;props.match.params.username&#125;!&lt;/h1&gt;;&#125;ReactDOM.render( &lt;Router&gt; &lt;Route path=\"/user/:username\" component=&#123;User&#125; /&gt; &lt;/Router&gt;, node); 不要尝试用内联方法的方式赋值给 component 属性，如以下示例所示： 1&lt;Route path=\"/user/:username\" component=&#123;() =&gt; &lt;User /&gt;)&#125; /&gt; 这样会导致每次重新渲染的时候都是一个新的 User 组件 render function在某些情况下，我们可能希望能经过一些计算来在一个路由上显示不同的组件。如下所示： 12345678910111213141516171819import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Route &#125; from \"react-router-dom\";const day = 1;// convenient inline renderingReactDOM.render( &lt;Router&gt; &lt;Route path=\"/home\" render=&#123;(props) =&gt; &#123; if(day === 1) &#123; return &lt;Monday /&gt; &#125; else &#123; return &lt;NotMonday /&gt; &#125; &#125;&#125; /&gt; &lt;/Router&gt;, node); 与将内联方法传递给 component 属性不同，使用此方式，不会造成组件的重复渲染 props 参数为 { match, location, history } component 属性的优先级要高于 render 。避免将两个属性同时使用在一个路由组件上。 children functionchildren function 与 render function 的使用方式一样。不同的地方在于，当路由匹配失败后，match 参数会是 null 。我们可以根据这个特性来做一些事情。 官网代码示例，这里在匹配上的时候，增加了一个class： 123456789101112131415161718192021222324252627282930import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Link, Route&#125; from \"react-router-dom\";function ListItemLink(&#123; to, ...rest &#125;) &#123; return ( &lt;Route path=&#123;to&#125; children=&#123;(&#123; match &#125;) =&gt; ( &lt;li className=&#123;match ? \"active\" : \"\"&#125;&gt; &lt;Link to=&#123;to&#125; &#123;...rest&#125; /&gt; &lt;/li&gt; )&#125; /&gt; );&#125;ReactDOM.render( &lt;Router&gt; &lt;ul&gt; &lt;ListItemLink to=\"/somewhere\" /&gt; &lt;ListItemLink to=\"/somewhere-else\" /&gt; &lt;/ul&gt; &lt;/Router&gt;, node); children 属性的优先级要高于 render 和 component 。避免将多个属性同时使用在一个路由组件上。","categories":[{"name":"React","slug":"React","permalink":"http://www.axin-blog.com/categories/React/"},{"name":"React-Router","slug":"React/React-Router","permalink":"http://www.axin-blog.com/categories/React/React-Router/"}],"tags":[{"name":"Route-Render","slug":"Route-Render","permalink":"http://www.axin-blog.com/tags/Route-Render/"}]}],"categories":[{"name":"node-cli","slug":"node-cli","permalink":"http://www.axin-blog.com/categories/node-cli/"},{"name":"git","slug":"node-cli/git","permalink":"http://www.axin-blog.com/categories/node-cli/git/"},{"name":"React","slug":"React","permalink":"http://www.axin-blog.com/categories/React/"},{"name":"React-Hook","slug":"React/React-Hook","permalink":"http://www.axin-blog.com/categories/React/React-Hook/"},{"name":"React-Router","slug":"React/React-Router","permalink":"http://www.axin-blog.com/categories/React/React-Router/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.axin-blog.com/tags/git/"},{"name":"Hook, async","slug":"Hook-async","permalink":"http://www.axin-blog.com/tags/Hook-async/"},{"name":"Route-Render","slug":"Route-Render","permalink":"http://www.axin-blog.com/tags/Route-Render/"}]}